if( live_call()) { return live_result }

if(instance_exists(sourceId)) {
	originX = sourceId.x;
	originY = sourceId.y;
}

var _fade = 0;
var _fadePortion = 1;
if(fadeTime > 0 && fadeTime <= fadeTimeMax) {
	_fadePortion = 1 - (fadeTime / fadeTimeMax);
	_fade = -((fadeTime * 2) / fadeTimeMax); // 0 to -2     to cut off alpha half way to over
	if(multipleChoice) {
		for(var _i = array_length(messageData) - 1; _i >= 0; _i--) {
			messageData[_i].blend(, max(1 + _fade, 0));
		}
	} else {
		messageData.blend(, max(1 + _fade, 0));
	}
}


if(multipleChoice) {
	for(var _i = array_length(messageData) - 1; _i >= 0; _i--) {
		messageData[_i].blend(c_white);
	}
	
	if(choiceHighlight != -1) {
		messageData[choiceHighlight].blend(c_yellow);
	}
}
	
#region speech bubble tail draw (thought bubble steps)
var _tailXOff = clamp((originX - x) / (abs(originY - y) * .01 + 1), -bubbleWidth * .55, bubbleWidth * .55);
draw_set_color(c_black);
for(var _pointI = 3; _pointI < 6; _pointI++) {
	draw_circle(lerp(originX, x + _tailXOff, _pointI / 6), lerp(originY, y, _pointI / 6), _fadePortion * (_pointI * .5 + 2 + dsin((_pointI * 173 + current_time)) * .7), false);
}
draw_set_color(c_white);
#endregion

#region The bubble itself (generated by a shader)
gpu_set_ztestenable(false);

shader_set(shd_speechBubbleFog);

shader_set_uniform_f(shader_get_uniform(shd_speechBubbleFog, "time"), current_time / 1000);
shader_set_uniform_f(shader_get_uniform(shd_speechBubbleFog, "colorTint"), 1, 1, 0, 1);
shader_set_uniform_f(shader_get_uniform(shd_speechBubbleFog, "bubbleSize"), .6 * bubbleWidth / 512, .6 * bubbleHeight / 512);
shader_set_uniform_f(shader_get_uniform(shd_speechBubbleFog, "bubbleRadius"), point_distance(.6 * bubbleWidth / 512, .6 * bubbleHeight / 512, 0, 0));
shader_set_uniform_f(shader_get_uniform(shd_speechBubbleFog, "radiusBufferAdjust"), _fade);


//var _bubbleSurf = getBubbleSurf();
//draw_surface(_bubbleSurf, x - 256, y - 256);

var _uvs = sprite_get_uvs(spr_box, 0);
shader_set_uniform_f(shader_get_uniform(shd_speechBubbleFog, "uvs"), _uvs[0], _uvs[1], _uvs[2] - _uvs[0], _uvs[3] - _uvs[1]); // x/y start, horizontal/vertical width

draw_sprite_ext(spr_box, 0, x + bubbleWidth * .5, y + bubbleHeight * .5, bubbleWidth, bubbleHeight, 0, c_white, 1);

shader_reset();
#endregion


if(createTime >= createTimeMax) { // active
	if(multipleChoice) {
		
		draw_circle(x, y, 5, true);
		draw_line_width(x - 7, y - 7, x + 7, y + 7, 1.5); // little cross icon in the center of choice bubble
		draw_line_width(x + 7, y - 7, x - 7, y + 7, 1.5);
		
		if(choiceHighlight != -1) {
			choiceArrowDirection -= angle_difference(choiceArrowDirection, choiceAngles[choiceHighlight]) * .21;
			
			draw_arrow(x, y, x + dcos(choiceArrowDirection) * 21, y - dsin(choiceArrowDirection) * 17, 9);
			
		}
		
		var _dir = 0;
		var _count = array_length(messageData);
		for(var _i = 0; _i < _count; _i++) {
			_dir = choiceAngles[_i]; // save angle to each option
			messageData[_i].draw(x + dcos(_dir) * 32, y - dsin(_dir) * 28); // how to use type writter with this?
		}
	} else {
		messageData.draw(x, y, typewritter);
	}
}

gpu_set_ztestenable(true);

//draw_circle(x, y, 12, false);