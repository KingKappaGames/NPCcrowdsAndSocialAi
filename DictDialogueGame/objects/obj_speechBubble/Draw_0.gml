if( live_call()) { return live_result }

if(instance_exists(sourceId)) {
	originX = sourceId.x;
	originY = sourceId.y;
}

var _fadeAlpha = 1;
var _fadePortion = 1;
if(fadeTime > 0 && fadeTime <= fadeTimeMax) {
	_fadePortion = 1 - (fadeTime / fadeTimeMax);
	_fadeAlpha = max(1 - ((fadeTime * 2.5) / fadeTimeMax), 0); // 1 to -1 clamped to 1 to 0 by half way     to cut off alpha half way to over
}


if(multipleChoice) {
	var _useChosenArray = false;
	_useChosenArray = !(choiceChosenArray == -1);
	for(var _i = array_length(messageData) - 1; _i >= 0; _i--) {
		var _col = choiceHighlight == _i ? bubbleTextColorHighlight : bubbleTextColor;
		var _optionAlreadyChosenFade = _useChosenArray ? 1 - min(choiceChosenArray[_i], 1) * .4 : 1;
		messageData[_i].blend(_col, _fadeAlpha * _optionAlreadyChosenFade);  // blend fade alpha with option chosen alpha (.4 alpha for already chosen ones)
	}
} else {
	messageData.blend(, _fadeAlpha);
}
	
#region speech bubble tail draw (thought bubble steps)
var _tailXOff = clamp((originX - x) / (abs(originY - y) * .01 + 1), -bubbleWidth * .55, bubbleWidth * .55);
draw_set_color(c_black);
for(var _pointI = 3; _pointI < 6; _pointI++) {
	draw_circle(lerp(originX, x + _tailXOff, _pointI / 6), lerp(originY, y, _pointI / 6), _fadeAlpha * (_pointI * .5 + 2 + dsin((_pointI * 173 + current_time)) * .7), false);
}
draw_set_color(c_white);
#endregion

#region The bubble itself (generated by a shader)
gpu_set_ztestenable(false);

var _shader;
var _colorTint;
if(bubbleType == "shadow") {
	_shader = shd_speechBubbleFog;
	_colorTint = c_yellow;
} else if(bubbleType == "white") {
	_shader = shd_speechBubbleWhite; // should the type just be a shader difference or what
	_colorTint = #360000;
}

shader_set(_shader);

shader_set_uniform_f(shader_get_uniform(shd_speechBubbleFog, "time"), current_time / 1000);
shader_set_uniform_f(shader_get_uniform(shd_speechBubbleFog, "colorTint"), color_get_red(_colorTint) / 255, color_get_green(_colorTint) / 255, color_get_blue(_colorTint) / 255, 1);
shader_set_uniform_f(shader_get_uniform(shd_speechBubbleFog, "bubbleSize"), .6 * bubbleWidth / 512, .6 * bubbleHeight / 512);
shader_set_uniform_f(shader_get_uniform(shd_speechBubbleFog, "bubbleRadius"), point_distance(.6 * bubbleWidth / 512, .6 * bubbleHeight / 512, 0, 0));
shader_set_uniform_f(shader_get_uniform(shd_speechBubbleFog, "radiusBufferAdjust"), _fadePortion * 2 - 2); // 0 to -2

var _uvs = sprite_get_uvs(spr_box, 0);
shader_set_uniform_f(shader_get_uniform(shd_speechBubbleFog, "uvs"), _uvs[0], _uvs[1], _uvs[2] - _uvs[0], _uvs[3] - _uvs[1]); // x/y start, horizontal/vertical width

draw_sprite_ext(spr_box, 0, x + bubbleWidth * .5 + bubbleDrawOffX, y + bubbleHeight * .5 + bubbleDrawOffY, bubbleWidth, bubbleHeight, 0, c_white, 1);

shader_reset();
#endregion


if(createTime >= createTimeMax) { // active
	if(multipleChoice) {
		draw_set_alpha(_fadeAlpha);
		draw_set_color(bubbleTextColor);
		draw_circle(x, y, 5, true);
		draw_line_width(x - 7, y - 7, x + 7, y + 7, 1.5); // little cross icon in the center of choice bubble
		draw_line_width(x + 7, y - 7, x - 7, y + 7, 1.5);
		
		if(choiceHighlight != -1) {
			choiceArrowDirection -= angle_difference(choiceArrowDirection, choiceAngles[choiceHighlight]) * .26;
			
			draw_arrow(x, y, x + dcos(choiceArrowDirection) * 21, y - dsin(choiceArrowDirection) * 17, 10);
		}
		
		draw_set_alpha(1);
		draw_set_color(c_white);
		
		var _dir = 0;
		var _count = array_length(messageData);
		for(var _i = 0; _i < _count; _i++) {
			_dir = choiceAngles[_i]; // save angle to each option
			messageData[_i].draw(x + dcos(_dir) * 32, y - dsin(_dir) * 28); // how to use type writter with this?
		}
	} else {
		messageData.draw(x, y, typewritter);
	}
}

gpu_set_ztestenable(true);

//draw_circle(x, y, 12, false);